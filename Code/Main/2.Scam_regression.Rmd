---
title: "2. Analysis - SCAM Regression & Economic Optimization"
author: "Jaeseok Hwang"
date: "`r Sys.Date()`"
output: html_document
---

# 1. Setup & Scenario Definition

```{r setup, message=FALSE, warning=FALSE, results='hide'}
library(knitr)
library(here)
library(data.table)
library(tidyverse)
library(scam)       # For Shape Constrained Additive Models (Concavity)
library(mgcv)       # General GAM utilities
library(parallel)   # For faster looping

# --- 1. Load Data Processing Functions ---
# (Required if you need to re-read any specific helper functions, though mostly standard libs used below)
source(here("Code", "src", "functions_for_processing.R"))

# --- 2. Load Project Setup & Price Data ---
# This executes the price calculation code you provided (corn_price_high, seed_price_high, etc.)
source(here("Code", "src", "set_up.R"))

# --- 3. Construct Analysis Scenarios ---
# We package the variables from set_up.R into lists for the analysis function

# Check if the variables exist (Safety check)
if(!exists("corn_price_high")) stop("Price variables (corn_price_high) not found. Check set_up.R")

# Scenario 1: High Cost Ratio (2016) - Conservative
# High Seed Price / Low Corn Price -> Expect Lower Optimal Rates
scenario_high_ratio <- list(
  name = "High_Cost_Ratio_2016",
  corn_p = corn_price_high,
  seed_p = seed_price_high
)

# Scenario 2: Low Cost Ratio (2021) - Aggressive
# Low Seed Price / High Corn Price -> Expect Higher Optimal Rates
scenario_low_ratio <- list(
  name = "Low_Cost_Ratio_2021",
  corn_p = corn_price_low,
  seed_p = seed_price_low
)

# Bundle them
scenarios_list <- list(scenario_high_ratio, scenario_low_ratio)

cat("Analysis Scenarios Configured:\n")
print(scenario_high_ratio)
print(scenario_low_ratio)

```

# Analysis Functions (SCAM regression)


```{r scam analysis, message=FALSE, warning=FALSE, results='hide'}

# Function to run analysis for a single field
analyze_field <- function(file_path, crop_type, scenarios) {
  
  # A. Load & Clean Data
  # --------------------
  dat_sf <- readRDS(file_path)
  dat <- as.data.table(sf::st_drop_geometry(dat_sf))
  
  field_id <- str_remove(basename(file_path), "_merged_data.rds")
  
  # 1. Outlier Removal (+/- 2 SD for s_rate)
  # This removes experimental errors or fill/boundary passes that skew the curve
  s_mean <- mean(dat$s_rate, na.rm=TRUE)
  s_sd   <- sd(dat$s_rate, na.rm=TRUE)
  dat_clean <- dat[s_rate >= (s_mean - 2*s_sd) & s_rate <= (s_mean + 2*s_sd)]
  
  # Skip fields with insufficient data points
  if(nrow(dat_clean) < 50) return(NULL) 
  
  # 2. Determine Farmer's Chosen Rate (S_chosen)
  # Median of the cleaned data represents the "Standard Practice"
  s_chosen <- median(dat_clean$s_rate, na.rm = TRUE)
  
  # B. Build Regression Model (SCAM)
  # -------------------------------
  # We use Shape Constrained Additive Models (SCAM) to enforce strictly concave yield response
  # bs = "cv" ensures Concavity in s_rate
  
  # Base controls (Spatial/Topographic variables)
  controls <- "+ s(elev, k=5) + s(slope, k=5) + s(clay, k=5) + s(water_storage, k=5)"
  
  # Logic to control for Nitrogen in Corn (if it exists)
  if (crop_type == "corn" && "n_rate" %in% names(dat_clean) && var(dat_clean$n_rate, na.rm=T) > 0) {
    f_formula <- as.formula(paste0("yield ~ s(s_rate, bs='cv', k=5) + s(n_rate, k=5)", controls))
    n_ref <- mean(dat_clean$n_rate, na.rm=TRUE) # Hold N constant at mean for prediction
  } else {
    f_formula <- as.formula(paste0("yield ~ s(s_rate, bs='cv', k=5)", controls))
    n_ref <- NA
  }
  
  # Fit Model
  m_scam <- tryCatch({
    scam(f_formula, data = dat_clean)
  }, error = function(e) return(NULL))
  
  if(is.null(m_scam)) return(NULL)
  
  # C. Optimization & Metrics
  # -------------------------
  # Create prediction grid: Min Observed -> Max Observed
  s_grid <- seq(min(dat_clean$s_rate), max(dat_clean$s_rate), length.out = 100)
  
  # Create "newdata" frame holding controls at field means
  newdata <- data.frame(
    s_rate = s_grid,
    n_rate = if(!is.na(n_ref)) n_ref else 0,
    elev = mean(dat_clean$elev, na.rm=T),
    slope = mean(dat_clean$slope, na.rm=T),
    clay = mean(dat_clean$clay, na.rm=T),
    water_storage = mean(dat_clean$water_storage, na.rm=T)
  )
  
  # Predict Yield Curve
  pred_yield <- predict(m_scam, newdata = newdata)
  
  # 1. Agronomic Maximum (Yield Max)
  max_idx <- which.max(pred_yield)
  y_max   <- pred_yield[max_idx]
  s_max   <- s_grid[max_idx]
  
  # 2. Yield at Minimum Seed Rate (Intercept proxy)
  y_min_rate <- pred_yield[1]
  
  # 3. Yield at Farmer Rate
  # Specific prediction for the exact s_chosen value
  newdata_farmer <- newdata[1,]
  newdata_farmer$s_rate <- s_chosen
  y_chosen <- predict(m_scam, newdata = newdata_farmer)
  
  # 4. Economic Optimization (EOSR)
  # Calculate Marginal Product (MP) = dy/ds
  dy_ds <- diff(pred_yield) / diff(s_grid)
  mid_s <- (s_grid[-1] + s_grid[-length(s_grid)]) / 2
  
  # Optimization Function
  calc_eosr <- function(corn_p, seed_p) {
    # Profit Max condition: MP = Price Ratio (P_seed / P_corn)
    ratio <- seed_p / corn_p
    
    # Find s_rate where MP is closest to Ratio
    # Note: Since curve is concave, MP is monotonically decreasing
    valid_idx <- which(dy_ds >= ratio)
    
    if(length(valid_idx) == 0) return(min(s_grid)) # Ratio too high, plant min
    if(length(valid_idx) == length(dy_ds)) return(max(s_grid)) # Ratio very low, plant max
    
    return(mid_s[max(valid_idx)])
  }
  
  eosr_high <- calc_eosr(scenarios[[1]]$corn_p, scenarios[[1]]$seed_p)
  eosr_low  <- calc_eosr(scenarios[[2]]$corn_p, scenarios[[2]]$seed_p)
  
  # D. Compile Results
  # ------------------
  res <- data.table(
    ffy_id = field_id,
    crop = crop_type,
    
    # Agronomic Behavior
    s_chosen = round(s_chosen, 0),
    y_chosen = round(y_chosen, 1),
    
    # Agronomic Potential
    s_max_yield = round(s_max, 0),
    y_max_yield = round(y_max, 1),
    y_at_min_s  = round(y_min_rate, 1),
    
    # Economic Optima
    eosr_2016_high_ratio = round(eosr_high, 0),
    eosr_2021_low_ratio  = round(eosr_low, 0),
    
    # Model Quality
    dev_expl = round(summary(m_scam)$dev.expl * 100, 1)
  )
  
  return(res)
}



```

# Execution Loop

```{r execute loop, message=FALSE, warning=FALSE, results='hide'}


crops <- c("corn", "soy")
all_results <- list()

for (crop in crops) {
  
  cat(paste0("\nRunning Analysis for: ", toupper(crop), "\n"))
  
  # Define input directory
  in_dir <- here("Data", crop, "Processed", "Analysis_Ready")
  
  if(!dir.exists(in_dir)) {
    cat("  Directory not found. Skipping.\n")
    next
  }
  
  files  <- list.files(in_dir, pattern = "_merged_data.rds", full.names = TRUE)
  
  if(length(files) == 0) {
    cat("  No data files found.\n")
    next
  }
  
  cat(paste("  Processing", length(files), "fields...\n"))
  
  # Run loop
  crop_res <- list()
  
  for (f in files) {
    # Call analysis function with our scenario list
    out <- analyze_field(f, crop, scenarios_list)
    if(!is.null(out)) crop_res[[length(crop_res)+1]] <- out
  }
  
  # Bind crop results
  if(length(crop_res) > 0) {
    all_results[[crop]] <- rbindlist(crop_res)
  }
}

# Combine all crops into one master table
master_results <- rbindlist(all_results, fill = TRUE)

# Save Results
save_path_rds <- here("Data", "Processed", "Analysis_Results_Master.rds")
save_path_csv <- here("Data", "Processed", "Analysis_Results_Master.csv")

# Ensure directory exists
dir.create(dirname(save_path_rds), recursive = TRUE, showWarnings = FALSE)

saveRDS(master_results, save_path_rds)
fwrite(master_results, save_path_csv)

cat("\nAnalysis Complete.\n")
cat("Results saved to:", save_path_csv, "\n")

# Preview
print(head(master_results))


```